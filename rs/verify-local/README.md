# [Verity Data Processor (VDP) - Verify local](https://github.com/usherlabs/verity-dp)

![License](https://img.shields.io/crates/l/verity-verify-local) [![verity_verify_local on crates.io](https://img.shields.io/crates/v/verity-verify-local)](https://crates.io/crates/verity-verify-local) [![verity_verify_local on docs.rs](https://docs.rs/verity_verify_local/badge.svg)](https://docs.rs/verity-verify-local)

## Overview
`verity_verify_local` is a Rust library crate designed to facilitate local verification of outputs generated by the Verity Verifier. It includes modules for cryptographic verification methods, such as ECDSA and Merkle tree-based verification, ensuring secure and accurate validation in a local environment.

## Features
- **ECDSA Verification**: Validate signatures using the ECDSA cryptographic algorithm.
- **Merkle Tree Verification**: Verify data integrity and authenticity using Merkle proofs.

## Modules

### 1. `ecdsa`
This module provides functionality for verifying ECDSA signatures locally.

#### Features:
- Support for validating signatures against provided public keys.
- High-performance and secure signature verification.

#### Example Usage:
```rust
use verity_verify_local::ecdsa;

fn main() {
    let public_key = "<public_key>";
    let message = b"example message";
    let signature = "<signature>";

    let is_valid = ecdsa::validate_ecdsa_signature(&signature, &message, &public_key).unwrap_or(false);
    println!("Signature valid: {}", is_valid);
}
```

### 2. `merkle`
This module implements Merkle tree verification for data integrity checks.

#### Features:
- Verify Merkle proofs to ensure data authenticity.
- Efficient support for large datasets.

#### Example Usage:
```rust
use verity_verify_local::merkle;

fn main() {
    let leaves = vec!["leaf1", "leaf2", "leaf3"].into_iter().map(String::from).collect::<Vec<_>>();
    let root_hash = "<root_hash>";

    let is_valid = merkle::validate_merkle_tree(&leaves, &root_hash);
    println!("Merkle Tree Root valid: {}", is_valid);
}
```

## Testing
The `verity_verify_local` crate includes comprehensive tests to validate the functionality of its modules. Below is an example test verifying a combined use case:

```rust
#[test]
fn test_validate_merkle_tree() {
    let sample_leaves: Vec<String> = vec![
        "HTTP/1.1 200 OK\r\nDate: Sun, 08 Sep 2024 11:32:39 GMT\r\nContent-Type: application/json; charset=utf-8\r\nContent-Length: 209\r\nConnection: close\r\nReport-To: {\"group\":\"heroku-nel\",\"max_age\":3600,\"endpoints\":[{\"url\":\"https://nel.heroku.com/reports?ts=1725782677&sid=e11707d5-02a7-43ef-b45e-2cf4d2036f7d&s=dxmGA3CFr3P4tKzR6kQOerpS%2FCNt3RMuKSMoJYDrIz0%3D\"}]}\r\nReporting-Endpoints: heroku-nel=https://nel.heroku.com/reports?ts=1725782677&sid=e11707d5-02a7-43ef-b45e-2cf4d2036f7d&s=dxmGA3CFr3P4tKzR6kQOerpS%2FCNt3RMuKSMoJYDrIz0%3D\r\nNel: {\"report_to\":\"heroku-nel\",\"max_age\":3600,\"success_fraction\":0.005,\"failure_fraction\":0.05,\"response_headers\":[\"Via\"]}\r\nX-Powered-By: Express\r\nX-Ratelimit-Limit: 1000\r\nX-Ratelimit-Remaining: 999\r\nX-Ratelimit-Reset: 1725782707\r\nVary: Origin, Accept-Encoding\r\nAccess-Control-Allow-Credentials: true\r\nCache-Control: max-age=43200\r\nPragma: no-cache\r\nExpires: -1\r\nX-Content-Type-Options: nosniff\r\nEtag: W/\"d1-AdCHAQW37rE37t8vXTeQZeKV7Cg\"\r\nVia: 1.1 vegur\r\nCF-Cache-Status: HIT\r\nAge: 12482\r\nAccept-Ranges: bytes\r\nServer: cloudflare\r\nCF-RAY: 8bfe9e828bc295f9-JNB\r\nalt-svc: h3=\":443\"; ma=86400\r\n\r\n{\n  \"userId\": 10,\n  \"id\": 98,\n  \"title\": \"laboriosam dolor voluptates\",\n  \"body\": \"doloremque ex facilis sit sint culpa\\nsoluta assumenda eligendi non ut eius\\nsequi ducimus vel quasi\\nveritatis est dolores\"\n}\n\nGET https://jsonplaceholder.typicode.com/posts/98 HTTP/1.1\r\nhost: jsonplaceholder.typicode.com\r\naccept: XXX\r\ncache-control: XXXXXXXX\r\nconnection: XXXXX\r\naccept-encoding: XXXXXXXX\r\n\r\n".to_string(),
        "2ba160a93050b676d0e4ae0b929f145f8382fe5920852cfc3ef550f230c1526a".to_string()
    ];
    let expected_root_hash =
        "7136b39c952e510735fef9fdb32a47151cc4474b0d718495a71d18ae88787eab".to_string();
    let public_key = "c4bb0da5d7cc269bca64a55e2149e6dc91dc7157".to_string();
    let expected_signature =
        "07a53a039f4c2f2338d04953ed2c01753f7454b76c38ba86d3058d3cb449e432673069fd5b7ac15916afeced3c0a7a74fe10679f0006f5a93764ef9cbe96c1db1c".to_string();

    // generate and validate merkle tree root hash
    let is_merkle_root_valid = validate_merkle_tree(&sample_leaves, &expected_root_hash);

    // perform an ecdsa signature verification on the tree root and signature
    let is_signature_valid = validate_ecdsa_signature(
        &expected_signature,
        &expected_root_hash,
        &public_key
    ).unwrap();

    assert!(is_merkle_root_valid, "INVALID MERKLE ROOT");
    assert!(is_signature_valid, "INVALID ECDSA SIGNATURE");
}
```

## Getting Started

### Installation
To include `verity_verify_local` in your project, add the following to your `Cargo.toml`:

```toml
[dependencies]
verity_verify_local = "0.1.0"
```

### Usage Example
Integrate the library to verify both ECDSA signatures and Merkle proofs:

```rust
use verity_verify_local::{ecdsa, merkle};

fn main() {
    // Example leaves and expected values
    let leaves = vec!["leaf1", "leaf2", "leaf3"].into_iter().map(String::from).collect::<Vec<_>>();
    let root_hash = "<root_hash>";
    let signature = "<signature>";
    let public_key = "<public_key>";

    // Validate Merkle Tree
    let is_merkle_valid = merkle::validate_merkle_tree(&leaves, &root_hash);
    println!("Merkle Tree Valid: {}", is_merkle_valid);

    // Validate ECDSA Signature
    let is_signature_valid = ecdsa::validate_ecdsa_signature(&signature, &root_hash, &public_key).unwrap_or(false);
    println!("Signature Valid: {}", is_signature_valid);
}
```

## Platform Support
This crate is platform-independent and designed for local environments where secure and efficient verification is required.

## License
`verity_verify_local` is licensed under the [MIT License](LICENSE).

