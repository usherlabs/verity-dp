// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{ VERITY_ZK_TESTS_ZKTLS_GUEST_ELF, VERITY_ZK_TESTS_ZKTLS_GUEST_ID };
use risc0_zkvm::{ default_prover, ExecutorEnv };
use verity_client::client::{ VerityClient, VerityClientConfig };

pub const DEFAULT_PROVER_URL: &str = "http://127.0.0.1:8080";

#[tokio::main()]
async fn main() -> Result<(), reqwest::Error> {
	// Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
	tracing_subscriber
		::fmt()
		.with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
		.init();

	// Entry point of the program
	println!("Hello Verity zkTLS Demo!");

	// Generate a TLS attestation using Verity Client
	// Pepare the TLS proof for the guest
	// Call the zkVM guest for zkSNARK
	// Verify the SNARK

	println!("Proving a GET request using VerityClient...");

	let config = VerityClientConfig {
		prover_url: String::from(DEFAULT_PROVER_URL),
	};

	let client = VerityClient::new(config);

	let result = client
		.get("https://jsonplaceholder.typicode.com/posts/98")
		.redact(String::from("res:body:dolor"))
		.send().await;

	let response = match result {
		Ok(response) => response,
		Err(e) => {
			println!("Error: {}", e);
			return Ok(());
		}
	};

	let json: serde_json::Value = response.subject.json().await.unwrap();
	println!("json: {:#?}", json);
	println!("response.proof.len(): {:#?}", response.proof.len());

	// Get the Notary information from the Prover
	let notaryinfo = client.get_notary_info().await;
	println!("notaryinfo: {:#?}", notaryinfo);

	let notary_pub_key = match notaryinfo {
		Ok(notaryinfo) => notaryinfo.public_key,
		Err(e) => {
			println!("Error: {}", e);
			return Ok(());
		}
	};

	// An executor environment describes the configurations for the zkVM
	// including program inputs.
	// An default ExecutorEnv can be created like so:
	// `let env = ExecutorEnv::builder().build().unwrap();`
	// However, this `env` does not have any inputs.
	//
	// To add guest input to the executor environment, use
	// ExecutorEnvBuilder::write().
	// To access this method, you'll need to use ExecutorEnv::builder(), which
	// creates an ExecutorEnvBuilder. When you're done adding input, call
	// ExecutorEnvBuilder::build().

	// For example:
	let input: u32 = 15 * u32::pow(2, 27) + 1;
	let env = ExecutorEnv::builder().write(&input).unwrap().build().unwrap();

	// Obtain the default prover.
	let prover = default_prover();

	// Proof information by proving the specified ELF binary.
	// This struct contains the receipt along with statistics about execution of the guest
	let prove_info = prover.prove(env, VERITY_ZK_TESTS_ZKTLS_GUEST_ELF).unwrap();

	// extract the receipt.
	let receipt = prove_info.receipt;

	// TODO: Implement code for retrieving receipt journal here.

	// For example:
	let _output: u32 = receipt.journal.decode().unwrap();

	// The receipt was verified at the end of proving, but the below code is an
	// example of how someone else could verify this receipt.
	receipt.verify(VERITY_ZK_TESTS_ZKTLS_GUEST_ID).unwrap();

	Ok(())
}
