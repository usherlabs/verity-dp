// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{Deserialize, Serialize};
use serde_json;
use std::env;
use verity_client::client::{VerityClient, VerityClientConfig};
use verity_dp_examples_zktls_methods::{
    VERITY_DP_EXAMPLES_ZKTLS_GUEST_ELF, VERITY_DP_EXAMPLES_ZKTLS_GUEST_ID,
};
use verity_verify_remote::{
    config::Config,
    ic::{Verifier, DEFAULT_IC_GATEWAY_LOCAL},
};
use verity_verify_tls::verify_proof;

pub const DEFAULT_PROVER_URL: &str = "http://127.0.0.1:8080";
pub const DEFAULT_VERITY_VERIFIER_ID: &str = "bkyz2-fmaaa-aaaaa-qaaaq-cai";

/// The input parameters for the zk_circuit
///
/// Contains the details needed for proof verification
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ZkInputParam {
    /// Session header information
    pub tls_proof: String,
    /// Precompute encodings
    pub encodings: Option<Vec<u8>>,
    /// Proof of substrings
    pub remote_verifier_proof: String,
    /// Remote verifier's ECDSA public key
    pub remote_verifier_public_key: String,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct RemoteVerificationProof {
    pub results: Vec<String>,
    pub root: String,
    pub signature: String,
}

#[tokio::main()]
async fn main() -> anyhow::Result<()> {
    env::set_var("RISC0_DEV_MODE", "1"); // Included to ensure the zkVM prover is fast for demo purposes.

    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Entry point of the program
    println!("Hello Verity zkTLS Demo!");

    // -------------------- // THE PLAN // ------------------------
    // Generate a TLS attestation using Verity Client
    // Prepare the TLS proof for the guest
    // Call the zkVM guest for zkSNARK
    // Verify the SNARK
    // -------------------- // THE PLAN // ------------------------

    println!("Proving a GET request using VerityClient...");

    let config = VerityClientConfig {
        prover_url: String::from(DEFAULT_PROVER_URL),
    };

    let client = VerityClient::new(config);

    let result = client
        .get("https://jsonplaceholder.typicode.com/posts/98")
        .redact(String::from("res:body:dolor"))
        .send()
        .await;

    let response = match result {
        Ok(response) => response,
        Err(e) => {
            println!("Error: {}", e);
            return Ok(());
        }
    };

    let json: serde_json::Value = response.subject.json().await.unwrap();
    println!("json: {:#?}", json);
    println!("response.proof.len(): {:#?}", response.proof.len());

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // Totally optional to verify proof on host too.
    // For the sake of this demo, we'll verify the proof on the host to ensure both the zkVM and host agree to the verification.
    let verified_by_host: (String, String) = verify_proof(&response.proof, None).unwrap();
    println!("verified_by_host: {:#?}", verified_by_host);
    // Perform the partial remote verification against decentralised compute

    // 1. Create a config file by specifying the params
    // ? To obtain this identity.pem, use `dfx identity export` - https://internetcomputer.org/docs/current/developer-docs/developer-tools/cli-tools/cli-reference/dfx-parent

    // TODO: This should eventually be abstracted away from the user...
    let rv_identity_path = "fixtures/identity.pem";
    let rv_id = DEFAULT_VERITY_VERIFIER_ID.to_string();
    let rv_config = Config::new(
        DEFAULT_IC_GATEWAY_LOCAL.to_string(),
        rv_identity_path.to_string(),
        rv_id,
    );

    // 2. Create verifier from a config file
    let remote_verifier = Verifier::from_config(&rv_config).await.unwrap();

    // 3.  Verify a proof and get the response
    let verified_by_remote = remote_verifier
        .verify_proof(
            // You can verify multiple proofs at once
            vec![response.proof.clone()],
        )
        .await
        .unwrap();

    // Assuming `verified_by_remote` is of type `VerifierResponse` and has a field `results`
    // which is a vector of some type that has a method `get_content()`.
    let leaves: Vec<String> = verified_by_remote
        .results
        .iter()
        .map(|proof_response| proof_response.get_content())
        .collect();

    // Create a `RemoteVerificationProof` instance
    let remote_verifier_proof = RemoteVerificationProof {
        results: leaves,
        root: verified_by_remote.root.clone(),
        signature: verified_by_remote.signature.clone(),
    };

    println!("\nverified_by_remote: {:#?}", remote_verifier_proof);

    // Now we have a proof of remote verification... We can use this to verify the private transcript data within the zkVM
    // ? The reason to split the proofs is because the crypto primitives used for session verification are not compatible zkVM and/or dramatically increase ZK proving times.

    // Start with the remote verifier's ECDSA public key
    let remote_verifier_public_key = remote_verifier.get_public_key().await.unwrap();

    // To do this, we need to serialize the data we pass to the zkVM
    let input = serde_json::to_string(
        &(ZkInputParam {
            tls_proof: response.proof.clone(),
            encodings: None,
            remote_verifier_proof: serde_json::to_string(&remote_verifier_proof).unwrap(),
            remote_verifier_public_key,
        }),
    )
    .unwrap();
    let input: &[u8] = input.as_bytes();

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    println!("Proving via zkVM...");

    // TODO: This zkVM prover will still take an absurd amount of time on a local machine...
    // This is because the crypto primitives involve randomness that causes zkVM to take a long time.
    // This is still a WIP and Usher Labs aims to solve this.
    // For the purpose of this demo, we will ensure RSIC0_DEV_MODE=1 is active.
    let prove_info = prover
        .prove(env, VERITY_DP_EXAMPLES_ZKTLS_GUEST_ELF)
        .unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    let verified_by_guest: (String, String) = receipt.journal.decode().unwrap();

    // Assert that the proof verification within the zkVM matches the proof verification by the host
    assert_eq!(verified_by_guest, verified_by_host);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(VERITY_DP_EXAMPLES_ZKTLS_GUEST_ID).unwrap();

    println!("STARK proof generated and verified!");

    println!("Host and guest both agree to the correctness of the TLS data.");

    Ok(())
}
