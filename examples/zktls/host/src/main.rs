use std::time::Instant;

use candid::{CandidType, Decode, Principal};
use ic_agent::{agent::http_transport::ReqwestTransport, identity::Secp256k1Identity, Agent};
use k256::pkcs8::DecodePublicKey;
use risc0_zkvm::{default_prover, ExecutorEnv, ProverOpts, Receipt};
use serde::Deserialize;
use serde_json;
use verity_client::client::{VerityClient, VerityClientConfig};
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use verity_dp_zk_methods::{VERITY_DP_ZK_VERIFY_ELF, VERITY_DP_ZK_VERIFY_ID};
use verity_verify_tls::{
    tlsn_core::presentation::Presentation, verify_private_facets, verify_public_facets,
    NotaryPubKey, PayloadBatch, PresentationBatch, ZkTlsProof,
};

pub const DEFAULT_PROVER_URL: &str = "http://127.0.0.1:8080";

/// Structure to hold receipt verification reply from verifying canister
#[derive(CandidType, Deserialize, Debug)]
pub struct VerifyReceiptReply {
    /// Arbitrary data committed by zkVM program, serialized by bincode
    pub data: Vec<u8>,
    /// Signature in hexadecimal format
    pub signature: String,
}

#[tokio::main()]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Entry point of the program
    println!("Hello Verity zkTLS Demo!");

    // -------------------- // THE PLAN // ------------------------
    // Generate a TLS attestation using Verity Client
    // Prepare the TLS proof for the guest
    // Call the zkVM guest for zkSNARK
    // Verify the SNARK
    // -------------------- // THE PLAN // ------------------------

    println!("Proving a GET request using VerityClient...");

    let config = VerityClientConfig {
        prover_url: String::from(DEFAULT_PROVER_URL),
    };

    let client = VerityClient::new(config);

    let response = client
        .get("https://mock.verity.usher.so/32b.json")
        // .get("https://mock.verity.usher.so/1kb.json")
        .header("API-KEY", "1234567890")
        .redact(String::from("req:header:api-key"))
        .send()
        .await?;

    let json: serde_json::Value = response.subject.json().await.unwrap();
    println!("json: {:#?}", json);
    println!("response.proof.len(): {:#?}", response.proof.len());

    let presentation: Presentation = serde_json::from_str(&response.proof)?;
    // Get the Notary information from the Prover
    let notary_info = client.get_notary_info().await?;
    println!("notary_info: {:#?}", notary_info);

    let notary_pub_key: NotaryPubKey =
        k256::PublicKey::from_public_key_pem(&notary_info.public_key)?
            .to_sec1_bytes()
            .into_vec();

    let proof_by_host = verify_by_host(&notary_pub_key, &presentation)?;
    println!("proof_by_host.hash: {:?}", hex::encode(&proof_by_host.hash));

    let (_payload, proof_by_zkvm, receipt) = verify_by_zkvm(&notary_pub_key, &presentation)?;
    println!("proof_by_zkvm.hash: {:?}", hex::encode(&proof_by_zkvm.hash));

    assert_eq!(proof_by_host.hash, proof_by_zkvm.hash);

    // Store the presentation
    // std::fs::write(
    //     "../../../fixtures/assets/presentation/presentation_32b.json",
    //     // "../../../fixtures/assets/presentation/presentation_1kb.json",
    //     serde_json::to_string(&presentation)?,
    // )?;

    // Store the receipt
    // std::fs::write(
    //     "../../../fixtures/assets/receipt/receipt_32b.bin",
    //     // "../../../fixtures/assets/receipt/receipt_1kb.bin",
    //     bincode::serialize(&receipt)?,
    // )?;

    let reply = verify_by_ic(receipt).await?;

    let batches = bincode::deserialize::<Vec<PayloadBatch>>(&reply.data)?;

    println!("batches: {:?}", batches);
    println!("signature: {:?}", hex::encode(reply.signature));

    Ok(())
}

fn verify_by_host(
    notary_pub_key: &NotaryPubKey,
    presentation: &Presentation,
) -> Result<ZkTlsProof, Box<dyn std::error::Error>> {
    let presentation_batch = PresentationBatch {
        notary_pub_key: notary_pub_key.clone(),
        presentations: vec![presentation.clone()],
    };

    let (private, _) = verify_private_facets(vec![presentation_batch.clone()])?;
    let public = verify_public_facets(vec![presentation_batch])?;

    assert_eq!(private.hash, public.hash);

    Ok(public)
}

fn verify_by_zkvm(
    notary_pub_key: &NotaryPubKey,
    presentation: &Presentation,
) -> Result<(Vec<u8>, ZkTlsProof, Receipt), Box<dyn std::error::Error>> {
    let presentation = presentation.clone();

    let presentation_batch = PresentationBatch {
        notary_pub_key: notary_pub_key.clone(),
        presentations: vec![presentation],
    };

    let presentation_batches = vec![presentation_batch];

    let input_bytes = bincode::serialize(&presentation_batches)?;

    let env = ExecutorEnv::builder()
        .write(&input_bytes.len())?
        .write_slice(&input_bytes)
        .build()?;

    // Obtain the default prover.
    let prover = default_prover();

    println!("starting to prove...");
    let start = Instant::now();
    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    // let prove_info = prover.prove(env, VERITY_DP_EXAMPLES_ZKTLS_GUEST_ELF)?;
    let prove_info =
        prover.prove_with_opts(env, VERITY_DP_ZK_VERIFY_ELF, &ProverOpts::succinct())?;

    // extract the receipt.
    let receipt = prove_info.receipt;

    println!("elapsed: {} seconds", start.elapsed().as_secs());

    let output_bytes: Vec<u8> = receipt.journal.decode()?;
    let (data, proof): (Vec<u8>, ZkTlsProof) = bincode::deserialize(&output_bytes)?;

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(VERITY_DP_ZK_VERIFY_ID)?;

    Ok((data, proof, receipt))
}

async fn verify_by_ic(receipt: Receipt) -> Result<VerifyReceiptReply, Box<dyn std::error::Error>> {
    let identity = Secp256k1Identity::from_pem_file(verity_fixtures::ic::IDENTITY_PATH)?;
    let agent = Agent::builder()
        .with_transport(ReqwestTransport::create("http://127.0.0.1:4943")?)
        .with_identity(identity)
        // .with_boxed_identity(Box::new(identity))
        .with_verify_query_signatures(true)
        .build()?;

    // This is required when talking to a local test instance
    agent.fetch_root_key().await?;

    let canister = Principal::from_text(verity_fixtures::ic::ZKTLS_VERIFIER)?;
    let method = "verify_receipt";

    let receipt_bytes = bincode::serialize(&receipt)?;

    let response = agent
        .update(&canister, method)
        .with_arg(candid::encode_one(receipt_bytes)?)
        .call_and_wait()
        .await?;

    let result = Decode!(&response, Result<VerifyReceiptReply, String>)?;

    result.map_err(|e| e.into())
}
